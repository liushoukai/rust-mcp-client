# AGENTS.md

## Project Overview

This is a Rust-based MCP (Model Context Protocol) server that provides public IP information query services. It uses the official `rmcp` SDK (v0.9.0) for MCP protocol implementation and communicates via stdio transport.

## Essential Commands

### Build
```bash
# Debug build
cargo build

# Release build (recommended for production)
cargo build --release
```

### Run
```bash
# Run directly
cargo run

# Run release binary
./target/release/rust-mcp-client
```

### Install System-wide
```bash
cargo install --path .
```

### Test
```bash
# Run manual MCP protocol tests
./test_mcp.sh

# Or test manually
cargo build
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}' | cargo run
```

## Code Organization

```
src/
├── main.rs      # Server entry point - creates IpInfoServer and starts stdio transport
├── server.rs    # MCP server implementation using rmcp SDK
└── lib.rs       # Business logic - IpInfo struct and fetch_ip_info()
```

**Separation of concerns:**
- `lib.rs`: Core business logic (HTTP requests, data models)
- `server.rs`: MCP protocol layer (tool definitions, routing)
- `main.rs`: Application startup and transport layer

## MCP Server Implementation Pattern

The project uses the `rmcp` SDK with procedural macros to simplify MCP protocol implementation:

### Server Structure
```rust
#[derive(Clone)]
pub struct IpInfoServer {
    tool_router: ToolRouter<Self>,  // Required field for #[tool_handler] macro
}

impl IpInfoServer {
    pub fn new() -> Self {
        IpInfoServer {
            tool_router: Self::tool_router(),  // Auto-generated by #[tool_router]
        }
    }
}
```

### Tool Definition Pattern
```rust
#[tool_router]
impl IpInfoServer {
    #[tool(description = "Tool description here")]
    pub async fn tool_name(&self) -> Result<CallToolResult, ErrorData> {
        // Implementation
        match crate::business_logic().await {
            Ok(result) => {
                let content = Content::text(result);
                Ok(CallToolResult::success(vec![content]))
            }
            Err(e) => {
                Err(ErrorData::internal_error(format!("Error: {}", e), None))
            }
        }
    }

    // With parameters
    #[tool(description = "Tool with params")]
    pub async fn tool_with_params(
        &self,
        #[tool(param)]
        #[schemars(description = "Param description")]
        param: String
    ) -> Result<CallToolResult, ErrorData> {
        // Implementation
    }
}
```

### Server Handler Pattern
```rust
#[tool_handler]
impl ServerHandler for IpInfoServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            instructions: Some("Server description".into()),
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            ..Default::default()
        }
    }
}
```

### Main Entry Pattern
```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let service = IpInfoServer::new();
    let server = service.serve(stdio()).await?;
    server.waiting().await?;
    Ok(())
}
```

## Key Macros (rmcp SDK)

- `#[tool_router]` - Generates `tool_router()` method and routing logic for tools
- `#[tool_handler]` - Implements ServerHandler trait with automatic MCP protocol methods
- `#[tool]` - Marks a method as an MCP tool with optional description/name
- `#[tool(param)]` - Marks function parameters as tool input parameters
- `#[schemars(description = "...")]` - Provides JSON Schema description for parameters

## Naming Conventions

- **Struct names**: PascalCase (e.g., `IpInfo`, `IpInfoServer`)
- **Function/method names**: snake_case (e.g., `get_ip_info`, `fetch_ip_info`)
- **Constants**: SCREAMING_SNAKE_CASE (not present in current code but Rust convention)
- **Module names**: snake_case (e.g., `server`, `main`)
- **Tool names**: snake_case, matching function names (e.g., `get_ip_info`)

## Code Style

- Uses Rust 2024 edition
- Async/await with tokio runtime
- `anyhow::Result` for main function error handling
- `Result<T, ErrorData>` for MCP tool return types
- Derive traits for serialization: `#[derive(Deserialize, Debug)]`
- Use `#[tool(param)]` with `#[schemars(description)]` for parameter documentation

## Testing Approach

The project uses manual MCP protocol testing via `test_mcp.sh`:
- Tests `initialize`, `tools/list`, and `tools/call` methods
- Uses `jq` for JSON output formatting
- Pipes JSON-RPC requests via stdin/stdout

No unit tests or integration tests currently exist.

## Important Gotchas

### Current Compilation Error
`src/server.rs:29` has a type mismatch:
```rust
// Current (broken):
let content = Content::json(ip_info.to_string());

// Content::json() returns Result<Annotated<RawContent>, ErrorData>
// Should be one of:
let content = Content::text(ip_info.to_string());
// OR
let content = Content::json(ip_info.to_string())?;
// OR
let content = Content::json(ip_info.to_string()).map_err(|e| ErrorData::internal_error(...))?;
```

### MCP Protocol Requirements
- **Method names are fixed by protocol**: `initialize`, `tools/list`, `tools/call`, etc. cannot be customized
- **Protocol version**: `2024-11-05`
- **Transport**: Uses stdio (stdin/stdout) for MCP communication
- **Response format**: All tool calls must return `Result<CallToolResult, ErrorData>`

### Content Creation
- `Content::text(...)` - For plain text responses
- `Content::json(...)` - For JSON responses (returns Result)
- Always wrap in `CallToolResult::success(vec![content])`

### Error Handling
Use `ErrorData` from rmcp:
```rust
ErrorData::internal_error(message, data)
ErrorData::invalid_request(message, data)
ErrorData::parse_error(message, data)
ErrorData::method_not_found(message, data)
ErrorData::invalid_params(message, data)
```

### Tool Parameters
- Use `#[tool(param)]` to mark parameters as tool inputs
- Use `#[schemars(description = "...")]` to provide parameter descriptions
- Parameters are automatically validated against JSON Schema generated by the SDK

## Dependencies

| Crate | Version | Features | Purpose |
|-------|---------|----------|---------|
| rmcp | 0.9.0 | server, transport-io | Official MCP SDK |
| reqwest | 0.12.26 | json | HTTP client |
| tokio | 1 | full | Async runtime |
| serde | 1.0.228 | derive | Serialization |
| serde_json | 1.0 | - | JSON handling |
| schemars | 1.0 | derive | JSON Schema generation |
| anyhow | 1.0 | - | Error handling |

## Adding New Tools

1. Add method to `#[tool_router]` impl block in `src/server.rs`
2. Mark with `#[tool(description = "...")]`
3. Add parameters with `#[tool(param)]` and `#[schemars(description = "...")]`
4. Implement logic, calling business functions from `lib.rs`
5. Return `Ok(CallToolResult::success(vec![content]))` on success
6. Return `Err(ErrorData::internal_error(...))` on failure

Example:
```rust
#[tool_router]
impl IpInfoServer {
    #[tool(description = "Check if IP is in range")]
    pub async fn check_ip_range(
        &self,
        #[tool(param)]
        #[schemars(description = "CIDR format IP range")]
        cidr: String
    ) -> Result<CallToolResult, ErrorData> {
        match crate::check_ip_range_impl(cidr).await {
            Ok(result) => {
                let content = Content::text(result);
                Ok(CallToolResult::success(vec![content]))
            }
            Err(e) => Err(ErrorData::internal_error(format!("Failed: {}", e), None))
        }
    }
}
```

## Claude Desktop Configuration

**Config locations:**
- macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
- Windows: `%APPDATA%\Claude\claude_desktop_config.json`
- Linux: `~/.config/Claude/claude_desktop_config.json`

**Example config:**
```json
{
  "mcpServers": {
    "ip-info": {
      "command": "/path/to/rust-mcp-client/target/release/rust-mcp-client"
    }
  }
}
```

## Debugging

### Claude Desktop Logs
- macOS: `~/Library/Logs/Claude/`
- Windows: `%APPDATA%\Claude\logs\`
- Linux: `~/.config/Claude/logs/`

### MCP Inspector
```bash
npx @modelcontextprotocol/inspector ./target/release/rust-mcp-client
```

### Manual Testing
```bash
# Test initialize
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}' | ./target/release/rust-mcp-client

# Test tools/list
echo '{"jsonrpc":"2.0","id":2,"method":"tools/list"}' | ./target/release/rust-mcp-client

# Test tools/call
echo '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"get_ip_info"}}' | ./target/release/rust-mcp-client
```

## Documentation

- `docs/MCP_PROTOCOL.md` - Detailed MCP protocol specification and usage guide
- `README.md` - Project overview and setup instructions (in Chinese)

## Related Resources

- [MCP Official Specification](https://spec.modelcontextprotocol.io/)
- [rmcp Crate Docs](https://docs.rs/rmcp/)
- [Official Rust SDK](https://github.com/modelcontextprotocol/rust-sdk)
